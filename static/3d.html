<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Huey3D - Voxel Adventure</title>
    <!-- Use same style as index.html but modified for 3D -->
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
        }

        /* --- UI STYLES (PORTED FROM INDEX.HTML) --- */
        #lobby-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #4a4a4a 0%, #2d2d2d 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .lobby-content {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        h1 {
            color: #ffcc00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0px #8a6d00;
        }

        .input-group {
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 18px;
            text-align: center;
            outline: none;
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            background: #ffcc00;
            color: #2d2d2d;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
        }

        .character-selection {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 25px;
            width: 100%;
        }

        .skin-option {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .skin-option.selected {
            border-color: #ffcc00;
            background: rgba(255, 204, 0, 0.2);
        }

        .skin-preview {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            object-fit: contain;
        }

        /* HUD & Inventory Styling */
        #inventory-overlay,
        #build-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500;
        }

        /* Harvesting UI */
        #harvest-bar-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -100px);
            width: 100px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 6px;
            display: none;
            z-index: 500;
        }

        #harvest-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffa726, #fb8c00);
            border-radius: 4px;
            transition: width 0.1s linear;
        }

        .inventory-content,
        .build-content {
            background: #3e2723;
            border: 4px solid #795548;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .inv-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        .inv-item-qty {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 0 2px;
        }

        #build-btn-hud {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 65px;
            height: 65px;
            background: #4db6ac;
            border: 4px solid #ffffff;
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: none;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
        }

        /* 3D UI Info */
        #game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            border: 1px solid #4db6ac;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            z-index: 1000;
        }

        #joystick-base {
            width: 100%;
            height: 100%;
            border: 2px solid #fff;
            border-radius: 50%;
            position: relative;
        }

        #joystick-thumb {
            width: 50px;
            height: 50px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            overflow: hidden;
            z-index: 500;
            display: none;
        }

        #minimap-content {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .minimap-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ff00;
            transform: translate(-50%, -50%);
        }
    </style>
</head>

<body>
    <div id="minimap">
        <div id="minimap-content">
            <div id="me-dot" class="minimap-dot" style="top:50%; left:50%; background:#0f0;"></div>
        </div>
    </div>
    <!-- Harvest HUD -->
    <div id="harvest-bar-container">
        <div id="harvest-bar-fill"></div>
    </div>

    <div id="game-ui" style="display:none;">
        <div class="info-panel">
            <h3 style="margin:0; color:#ffcc00;">ü¶ä Huey3D</h3>
            <div id="player-nick" style="font-weight:bold;">...</div>
            <div id="online-count" style="font-size:12px; color:#4db6ac;">Online: 1</div>
            <div id="controls-hint" style="font-size:12px; color:#ccc; margin-top:5px;">
                WASD: Move | LeftClick: Build | RightClick: Remove | ESC: Build Menu
            </div>
        </div>
    </div>

    <!-- Build HUD Button -->
    <div id="build-btn-hud" onclick="toggleBuildMenu()">üî®</div>

    <!-- Lobby -->
    <div id="lobby-overlay">
        <div class="lobby-content">
            <h1>Huey World 3D</h1>
            <div class="input-group">
                <input type="text" id="nickname-input" placeholder="Enter Nickname" maxlength="12">
            </div>
            <div class="character-selection">
                <div class="skin-option selected" data-skin="skin_fox">
                    <img src="static/assets/skin_fox.png?v=2" class="skin-preview"><span
                        style="font-size:10px; color:#fff;">FOX</span>
                </div>
                <!-- Other skins Omitted for brevity but can be added back -->
            </div>
            <button id="join-btn">JOIN WORLD</button>
            <button id="logout-btn" style="margin-top:10px; font-size:14px; background:#555; color:#fff;">Log
                Out</button>
        </div>
    </div>

    <!-- Inventory Overlay -->
    <div id="inventory-overlay">
        <div class="inventory-content">
            <div class="inventory-header">
                <h2>üéí Ïù∏Î≤§ÌÜ†Î¶¨ (Inventory)</h2>
                <span onclick="toggleInventory()" style="cursor:pointer; font-size:24px;">√ó</span>
            </div>
            <div id="inventory-grid" class="inventory-grid">
                <!-- Slots generated by JS -->
            </div>
            <button onclick="toggleInventory()" style="background:#555;">Close</button>
        </div>
    </div>

    <!-- Build Overlay -->
    <div id="build-overlay">
        <div class="build-content">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="color: #4db6ac; margin: 0;">üî® Construct World</h2>
                <span onclick="toggleBuildMenu()" style="cursor:pointer; color:#fff; font-size:24px;">√ó</span>
            </div>
            <div class="inventory-grid" id="build-menu-grid">
                <!-- Ported from index.html -->
                <div class="inv-slot" id="build-item-voxel_box" onclick="startPlacement('voxel_box')">üì¶<div
                        style="font-size:8px;">Box (1 Wood)</div>
                </div>
                <div class="inv-slot" id="build-item-fence_wood" onclick="startPlacement('fence_wood')">ü™µ<div
                        style="font-size:8px;">Fence (2 Wood)</div>
                </div>
                <div class="inv-slot" id="build-item-wall_stone" onclick="startPlacement('wall_stone')">üß±<div
                        style="font-size:8px;">Wall (2 Crystal)</div>
                </div>
                <div class="inv-slot" id="build-item-remove" onclick="startPlacement('remove')"
                    style="border-color:#f44336;">‚ùå<div style="font-size:8px; color:#f44336;">Remove</div>
                </div>
            </div>
            <button onclick="toggleBuildMenu()" style="background:#555;">Cancel</button>
        </div>
    </div>

    <!-- Mobile UI Component -->
    <div id="mobile-controls">
        <div id="joystick-base">
            <div id="joystick-thumb"></div>
        </div>
    </div>

    <!-- Core Libs -->
    <script src="/static/js/vendor/socket.io.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let socket;
        let myAvatar;
        let mySprite;
        let otherPlayers = {};
        let inventory = [];
        let isJoined = false;
        let buildMode = null; // null or 'voxel_box' etc.

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue

        // Fog for depth (Increased for better view)
        scene.fog = new THREE.Fog(0x87ceeb, 20, 300);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Infinite Grid (Keep for dev)
        const grid = new THREE.GridHelper(2000, 40, 0x000000, 0x444444);
        grid.position.y = -0.01;
        scene.add(grid);

        // --- 1.1 Biome Floors ---
        function createBiomeFloors() {
            const size = 2000;
            // Center (Forest)
            const forestGeo = new THREE.PlaneGeometry(size, 1400);
            const forestMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 }); // Deep Green
            const forest = new THREE.Mesh(forestGeo, forestMat);
            forest.rotation.x = -Math.PI / 2;
            forest.receiveShadow = true;
            scene.add(forest);

            // North (Snow)
            const snowGeo = new THREE.PlaneGeometry(size, 650);
            const snowMat = new THREE.MeshLambertMaterial({ color: 0xeceff1 }); // Snowy White
            const snow = new THREE.Mesh(snowGeo, snowMat);
            snow.rotation.x = -Math.PI / 2;
            snow.position.z = -1000 + 325; // Top area
            snow.receiveShadow = true;
            scene.add(snow);

            // South (Desert)
            const desertGeo = new THREE.PlaneGeometry(size, 650);
            const desertMat = new THREE.MeshLambertMaterial({ color: 0xffecb3 }); // Sandy Yellow
            const desert = new THREE.Mesh(desertGeo, desertMat);
            desert.rotation.x = -Math.PI / 2;
            desert.position.z = 1000 - 325; // Bottom area
            desert.receiveShadow = true;
            scene.add(desert);
        }
        createBiomeFloors();

        const worldObjects = [];
        // Invisible plane for raycasting (Full size)
        const floorGeo = new THREE.PlaneGeometry(2000, 2000);
        const floorMat = new THREE.MeshBasicMaterial({ visible: false });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        worldObjects.push(floor);

        // --- 1.3 Harvesting Logic ---
        let isHarvesting = false;
        let harvestProgress = 0;
        let harvestTarget = null;
        const HARVEST_TIME = 2000; // 2 seconds

        function updateHarvesting(dt) {
            if (!isJoined) return;

            // 1. Find Nearest Tree
            let nearest = null;
            let minDist = 3; // 3 units in 3D

            worldObjects.forEach(obj => {
                if (obj.userData && obj.userData.parentGroup) {
                    const dist = controls.target.distanceTo(obj.userData.parentGroup.position);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = obj.userData.parentGroup;
                    }
                }
            });

            if (nearest && !isHarvesting) {
                // Potential target found
                startHarvesting(nearest);
            } else if (!nearest && isHarvesting) {
                cancelHarvesting();
            } else if (nearest && isHarvesting && nearest !== harvestTarget) {
                // Switched tree
                cancelHarvesting();
                startHarvesting(nearest);
            }

            // 2. Advance Progress
            if (isHarvesting) {
                harvestProgress += dt;
                const percent = Math.min(100, (harvestProgress / HARVEST_TIME) * 100);
                document.getElementById('harvest-bar-fill').style.width = percent + '%';

                // Visual Feedback: Shake tree
                if (harvestTarget) {
                    harvestTarget.rotation.z = Math.sin(Date.now() * 0.02) * 0.05;
                }

                if (harvestProgress >= HARVEST_TIME) {
                    completeHarvesting();
                }
            }
        }

        function startHarvesting(target) {
            isHarvesting = true;
            harvestProgress = 0;
            harvestTarget = target;
            document.getElementById('harvest-bar-container').style.display = 'block';
        }

        function cancelHarvesting() {
            if (harvestTarget) harvestTarget.rotation.z = 0;
            isHarvesting = false;
            harvestProgress = 0;
            harvestTarget = null;
            document.getElementById('harvest-bar-container').style.display = 'none';
        }

        async function completeHarvesting() {
            // Logic to update inventory (mirroring 2D effect)
            // Note: server update needed for real persistence if not handled by standard movement
            console.log("Harvest Complete!");
            // Temporary: Add dummy item locally to test UI
            inventory.push({ item_id: 'wood', quantity: 1, slot_index: inventory.length });
            renderInventoryUI();

            // Cleanup
            const target = harvestTarget;
            cancelHarvesting();

            // Respawn fade out (Voxel style)
            if (target) {
                target.visible = false;
                setTimeout(() => { target.visible = true; }, 10000);
            }
        }

        // --- 1.4 Day/Night Logic ---
        let worldTime = 0.5; // Shared state
        function updateAtmosphere(time) {
            worldTime = time;

            // Sky & Fog Colors (Mirroring server logic)
            // 0.0 (Midnight), 0.25 (Dawn), 0.5 (Noon), 0.75 (Dusk)
            let skyColor, ambientIntensity;

            if (worldTime < 0.2) { // Midnight
                skyColor = new THREE.Color(0x0a192f);
                ambientIntensity = 0.2;
            } else if (worldTime < 0.4) { // Dawn
                skyColor = new THREE.Color(0x5c6bc0);
                ambientIntensity = 0.4;
            } else if (worldTime < 0.7) { // Day
                skyColor = new THREE.Color(0x87ceeb);
                ambientIntensity = 0.7;
            } else { // Dusk
                skyColor = new THREE.Color(0xff8a65);
                ambientIntensity = 0.4;
            }

            scene.background = skyColor;
            if (scene.fog) scene.fog.color = skyColor;
            ambientLight.intensity = ambientIntensity;

            // Directional light (Sun) movement
            const angle = worldTime * Math.PI * 2;
            dirLight.position.set(Math.cos(angle) * 20, Math.sin(angle) * 20, 10);
            dirLight.intensity = Math.max(0, Math.sin(angle)) * 0.8 + 0.2;
        }

        // --- 1.2 Voxel Models ---
        function createVoxelTree(x, z, type = 'forest') {
            const group = new THREE.Group();

            // Trunk
            const trunkGeo = new THREE.BoxGeometry(0.8, 2, 0.8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);

            // Leaves
            const leafGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            let leafColor = 0x2e7d32;
            if (type === 'snow') leafColor = 0xbbdefb;
            if (type === 'desert') leafColor = 0xcddc39;

            const leaves = new THREE.Mesh(leafGeo, new THREE.MeshLambertMaterial({ color: leafColor }));
            leaves.position.y = 3;
            leaves.castShadow = true;
            group.add(leaves);

            group.position.set(x, 0, z);
            scene.add(group);

            // Add trunk to worldObjects for raycasting/building on
            trunk.userData = { parentGroup: group }; // for identification
            worldObjects.push(trunk);
        }

        // --- 2. System Integration (Auth & Sync) ---
        const token = localStorage.getItem('hueyworld_token');
        const loginData = JSON.parse(localStorage.getItem('hueyworld_user') || '{}');
        if (loginData.nickname) document.getElementById('nickname-input').value = loginData.nickname;

        document.getElementById('join-btn').onclick = () => {
            const nick = document.getElementById('nickname-input').value || "Fox";
            initGame(nick);
        };

        async function initGame(nickname) {
            document.getElementById('lobby-overlay').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('build-btn-hud').style.display = 'flex';
            document.getElementById('player-nick').innerText = nickname;

            // --- LOCAL AVATAR SETUP ---
            initLocalAvatar(nickname, loginData.skin || 'skin_fox');

            // Socket.IO Init
            socket = io('http://' + window.location.hostname + ':8001');

            socket.on('connect', () => {
                socket.emit('set_nickname', { nickname, token });
            });

            socket.on('current_players', (players) => {
                for (let sid in players) {
                    if (sid !== socket.id) updateOtherPlayer(sid, players[sid]);
                }
            });

            socket.on('player_moved', (data) => {
                if (data.sid !== socket.id) updateOtherPlayer(data.sid, data);
            });

            socket.on('new_player', (data) => {
                if (data.sid !== socket.id) updateOtherPlayer(data.sid, data.player);
            });

            socket.on('player_disconnected', (sid) => {
                if (otherPlayers[sid]) {
                    scene.remove(otherPlayers[sid].group);
                    delete otherPlayers[sid];
                }
            });

            socket.on('object_placed', (data) => {
                renderVoxel(data.x, data.y, data.z, data.type);
            });

            socket.on('npcs_moved', (data) => {
                updateNPCs(data);
            });

            isJoined = true;
            fetchInventory();
            loadWorld();
        }

        function initLocalAvatar(nickname, skin) {
            myAvatar = new THREE.Group();

            // Billboard Sprite
            const loader = new THREE.TextureLoader();
            const tex = loader.load(`/static/assets/${skin}.png`);
            tex.magFilter = THREE.NearestFilter;
            const mat = new THREE.SpriteMaterial({ map: tex });
            mySprite = new THREE.Sprite(mat);
            mySprite.scale.set(1.5, 1.5, 1);
            mySprite.position.y = 0.75;
            myAvatar.add(mySprite);

            // Nickname label
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            ctx.fillStyle = 'white'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText(nickname, 128, 40);
            const nameTex = new THREE.CanvasTexture(canvas);
            const nameMat = new THREE.SpriteMaterial({ map: nameTex });
            const nameSprite = new THREE.Sprite(nameMat);
            nameSprite.scale.set(2, 0.5, 1);
            nameSprite.position.y = 1.6;
            myAvatar.add(nameSprite);

            scene.add(myAvatar);
        }

        // --- 2.1 NPC Logic ---
        let otherNPCs = {};
        function updateNPCs(data) {
            for (let nid in data) {
                const npcData = data[nid];
                if (!otherNPCs[nid]) {
                    const group = new THREE.Group();
                    const loader = new THREE.TextureLoader();
                    // npcData doesn't always have type in movement packet, 
                    // ideally server sends type once on join or in packet.
                    // For now fallback to roach
                    const tex = loader.load(`/static/assets/roach.png`);
                    tex.magFilter = THREE.NearestFilter;
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                    sprite.scale.set(1.2, 1.2, 1);
                    sprite.position.y = 0.6;
                    group.add(sprite);

                    scene.add(group);
                    otherNPCs[nid] = { group, sprite };
                }
                const n = otherNPCs[nid];
                n.group.position.set(npcData.x / 20, 0, npcData.y / 20);
                // Simple bobbing
                n.sprite.position.y = 0.6 + Math.abs(Math.sin(Date.now() * 0.01 + nid)) * 0.1;
            }
        }
        function updateOtherPlayer(sid, data) {
            if (!otherPlayers[sid]) {
                const group = new THREE.Group();

                // Billboard Sprite
                const loader = new THREE.TextureLoader();
                const tex = loader.load(`/static/assets/${data.skin || 'skin_fox'}.png`);
                tex.magFilter = THREE.NearestFilter;
                const mat = new THREE.SpriteMaterial({ map: tex });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(1.5, 1.5, 1);
                sprite.position.y = 0.75;
                group.add(sprite);

                // Nickname label
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(data.nickname || '...', 128, 40);
                const nameTex = new THREE.CanvasTexture(canvas);
                const nameMat = new THREE.SpriteMaterial({ map: nameTex });
                const nameSprite = new THREE.Sprite(nameMat);
                nameSprite.scale.set(2, 0.5, 1);
                nameSprite.position.y = 1.6;
                group.add(nameSprite);

                scene.add(group);
                otherPlayers[sid] = { group, sprite, data };
            }

            const p = otherPlayers[sid];
            p.group.position.set(data.x, data.z, data.y); // Note mapping

            // Animation (Bobbing)
            if (data.isMoving) {
                p.sprite.position.y = 0.75 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.2;
            } else {
                p.sprite.position.y = 0.75;
            }
        }

        async function fetchInventory() {
            if (!token) return;
            const res = await fetch('/api/inventory/get', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token })
            });
            const data = await res.json();
            if (data.success) {
                inventory = data.inventory;
                renderInventoryUI();
            }
        }

        function renderInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            const emojiMap = { 'wood': 'ü™µ', 'forest_apple': 'üçé', 'frozen_wood': 'üßä', 'snow_crystal': 'üíé', 'cactus_fiber': 'üßµ', 'desert_fruit': 'üåµ' };

            for (let i = 0; i < 20; i++) {
                const item = inventory.find(it => it.slot_index === i);
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                if (item) {
                    slot.innerText = emojiMap[item.item_id] || 'üì¶';
                    if (item.quantity > 1) {
                        const qty = document.createElement('span');
                        qty.className = 'inv-item-qty';
                        qty.innerText = item.quantity;
                        slot.appendChild(qty);
                    }
                }
                grid.appendChild(slot);
            }
        }

        window.toggleInventory = () => {
            const inv = document.getElementById('inventory-overlay');
            inv.style.display = inv.style.display === 'flex' ? 'none' : 'flex';
        };

        document.getElementById('logout-btn').onclick = () => {
            localStorage.removeItem('hueyworld_user');
            localStorage.removeItem('hueyworld_token');
            window.location.reload();
        };

        // Key Listeners for UI
        window.addEventListener('keydown', (e) => {
            if (e.key === 'i') toggleInventory();
            if (e.key === 'b') toggleBuildMenu();
            if (e.key === 'Escape') {
                document.getElementById('inventory-overlay').style.display = 'none';
                document.getElementById('build-overlay').style.display = 'none';
            }
        });

        async function loadWorld() {
            // 1. Load Trees (Static Map)
            try {
                const res = await fetch('/static/db/map/forest.json');
                const trees = await res.json();
                trees.forEach(t => {
                    // Map: 2D (x, y) scaling. 
                    // Let's scale down the world slightly for better 3D spacing (1:10)
                    const x = t.x / 20;
                    const z = t.y / 20;
                    let type = 'forest';
                    if (t.y < -700) type = 'snow';
                    if (t.y > 700) type = 'desert';
                    createVoxelTree(x, z, type);
                });
            } catch (e) {
                console.error("Tree load error:", e);
            }

            // 2. Load Placed Objects
            const res = await fetch('/api/world/objects');
            const data = await res.json();
            if (data.success) {
                data.objects.forEach(obj => renderVoxel(obj.x / 20, obj.y / 20, obj.z, obj.type));
            }
        }

        function renderVoxel(x, z, y, type) {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const isFire = type === 'bonfire';
            const mat = new THREE.MeshLambertMaterial({ color: (isFire ? 0xff5722 : 0x4db6ac) });
            const voxel = new THREE.Mesh(geo, mat);
            voxel.position.set(x, y + 0.5, z);
            voxel.castShadow = true;
            voxel.receiveShadow = true;
            scene.add(voxel);
            worldObjects.push(voxel);

            if (isFire) {
                const light = new THREE.PointLight(0xffab40, 3, 10);
                light.position.set(x, y + 1.2, z);
                scene.add(light);
                // Flicker effect can be added in animate loop
            }
        }

        // --- 3. Interaction & Build Mode ---
        const BUILD_COSTS = {
            'fence_wood': { 'wood': 2 },
            'wall_stone': { 'snow_crystal': 2 },
            'bonfire': { 'wood': 1, 'cactus_fiber': 1 },
            'voxel_box': { 'wood': 1 }
        };

        window.toggleBuildMenu = () => {
            const overlay = document.getElementById('build-overlay');
            overlay.style.display = overlay.style.display === 'flex' ? 'none' : 'flex';
            if (overlay.style.display === 'flex') updateBuildMenuAffordability();
        };

        function updateBuildMenuAffordability() {
            for (const [id, costs] of Object.entries(BUILD_COSTS)) {
                let canAfford = true;
                for (const [item_id, qty] of Object.entries(costs)) {
                    const invItem = inventory.find(it => it.item_id === item_id);
                    if (!invItem || invItem.quantity < qty) { canAfford = false; break; }
                }
                // (Note: in 3D we didn't add IDs to slots yet, would need them for gray-out)
            }
        }

        window.startPlacement = (type) => {
            if (type !== 'remove') {
                const costs = BUILD_COSTS[type];
                let canAfford = true;
                for (const [item_id, qty] of Object.entries(costs)) {
                    const invItem = inventory.find(it => it.item_id === item_id);
                    if (!invItem || invItem.quantity < qty) { canAfford = false; break; }
                }
                if (!canAfford) { alert("Not enough materials!"); return; }
            }
            buildMode = type;
            toggleBuildMenu();
            console.log("Entering Build Mode:", type);
        };

        // Raycasting for Mouse Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', async (e) => {
            if (!isJoined || !buildMode) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(worldObjects);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const pos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.5));
                const gx = Math.floor(pos.x);
                const gy = Math.floor(pos.y);
                const gz = Math.floor(pos.z);

                if (buildMode === 'remove') {
                    if (intersect.object !== floor) {
                        const res = await fetch('/api/world/remove', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                token,
                                x: intersect.object.position.x * 20,
                                y: intersect.object.position.z * 20
                            })
                        });
                        if (res.ok) {
                            scene.remove(intersect.object);
                            worldObjects.splice(worldObjects.indexOf(intersect.object), 1);
                            fetchInventory();
                        }
                    }
                } else {
                    // Place logic via API
                    const res = await fetch('/api/world/place', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token, type: buildMode, x: gx * 20, y: gz * 20, z: gy })
                    });
                    if (res.ok) fetchInventory();
                }
            }
        });

        // --- 4. Mobile Support (Joystick) ---
        let joystickActive = false;
        let joystickVector = new THREE.Vector2(0, 0);
        const stick = document.getElementById('joystick-thumb');
        const base = document.getElementById('joystick-base');

        base.addEventListener('touchstart', (e) => { joystickActive = true; moveStick(e); });
        window.addEventListener('touchmove', (e) => { if (joystickActive) moveStick(e); });
        window.addEventListener('touchend', () => {
            joystickActive = false;
            stick.style.left = '50%'; stick.style.top = '50%';
            joystickVector.set(0, 0);
        });

        function moveStick(e) {
            const rect = base.getBoundingClientRect();
            const touch = e.touches[0];
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = rect.width / 2;

            if (dist > maxDist) {
                dx *= (maxDist / dist);
                dy *= (maxDist / dist);
            }

            stick.style.left = (50 + (dx / rect.width * 100)) + '%';
            stick.style.top = (50 + (dy / rect.height * 100)) + '%';

            joystickVector.set(dx / maxDist, dy / maxDist);
        }

        // --- 5. Game Loop ---
        const moveSpeed = 0.15;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = now - lastTime;
            lastTime = now;

            const isMoving = joystickActive;
            if (isMoving) {
                camera.position.x += joystickVector.x * moveSpeed;
                camera.position.z += joystickVector.y * moveSpeed;
                controls.target.x += joystickVector.x * moveSpeed;
                controls.target.z += joystickVector.y * moveSpeed;
            }

            updateHarvesting(dt);

            // Update Local Avatar Position
            if (myAvatar) {
                myAvatar.position.copy(controls.target);
                if (isMoving) {
                    mySprite.position.y = 0.75 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.2;
                } else {
                    mySprite.position.y = 0.75;
                }

                // Update Minimap Dot (Current Player)
                const meDot = document.getElementById('me-dot');
                if (meDot) {
                    // Map 3D (-50 to 50) -> Minimap (0% to 100%)
                    const mx = (controls.target.x / 50) * 50 + 50;
                    const my = (controls.target.z / 50) * 50 + 50;
                    meDot.style.left = mx + '%';
                    meDot.style.top = my + '%';
                }
            }

            // Sync My Position
            if (isJoined && socket && (isMoving || Date.now() % 100 < 20)) {
                socket.emit('player_move', {
                    x: controls.target.x,
                    y: controls.target.z,
                    z: controls.target.y,
                    isMoving: isMoving
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>

</html>